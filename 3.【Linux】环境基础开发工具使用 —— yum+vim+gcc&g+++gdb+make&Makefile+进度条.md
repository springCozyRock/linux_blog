Lesson3 Linux环境基础开发工具使用

[TOC]

> 本文将继续介绍指令及相关知识，帮助我们进行部分的系统管理，学会使用大部分的开发工具。

正文开始@边通书

# 1. Linux软件包管理器yum

## 1.1 什么是软件包

在Linux下，安装软件肯定不会那么方便，它有这三种方式 ——

1. 源码安装：下载程序的源代码，您自己编译吧，得到可执行程序。但这会有交叉编译环境的问题。
2. rpm安装：别人把在不同环境下给我提前**编译打包好**， 做成软件包，我们直接安装。

但是在开发时，软件之间存在大量的依赖关系，安装非常麻烦，这就要引出**yum**，它**本身**会**考虑依赖关系**。

3. :yum: **yum** [*Yellow dog Updater,Modified*]：相当于Linux下进行软件安装的客户端。



## 1.2 软件安装三板斧

### 1.2.1 查看软件包

:yellow_heart: 默认列出**所有软件**

```c
sudo yum list
```

但是包的数目可能很多，可以**配合管道**和**行过滤工具**进行过滤搜索

以sl小火车为例 ——

```c
sudo yum list | grep sl  或   sudo yum list | grep sl.x86 
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220220194435087.png" alt="image-20220220194435087" style="zoom:80%;" />

严格匹配，转义一下

```c
yum list | grep 'sl\.x86_64'
```





### 1.2.2 安装软件

:yellow_heart: 安装软件

```c
sudo yum install sl.x86_64   以sl小火车为例
```

可能有询问信息，您别问了，直接装吧！

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220220195413678.png" alt="image-20220220195413678" style="zoom:80%;" />

```c
sudo yum -y install sl
```

注意：

- [ ] yum 要工作，必须联网

- [ ] centos里，只能有一个yum在工作

- [ ] 一般安装软件不建议以root身份安装，建议使用普通用户。但是由于需要向系统目录中写入内容，会涉及权限问题，我们可以`sodu`进行临时权限提升或者`su`切换身份。(关于`sodu`的信任关系的配置会在本文***2.4***节阐明，建议学会vim后再进行配置）

- [ ] centOS安装软件对应的服务器一般都在国外，可能需要更新yum源这里上网上随便找一篇博客改一下，出问题了再改也来得及。

- [ ] 安装扩展源 

  ```c
  sudo yum install -y -epel-release
  ```

  



至于要装什么软件，随学随装即可

这些都可以装着玩一玩 ——

```c
sudo yum install cowsay.noarch
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220220201721953.png" alt="image-20220220201721953" style="zoom:80%;" />



可以在Linux和windows之间拖拽式的上传软件

```c
sudo yum install lrzsz
```

![image-20220220203522533](C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220220203522533.png)

也可以不拖拽，通过指令 ——

```c
rz -E  接收：云服务器可接收本地机器上的指定文件
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220220205425428.png" alt="image-20220220205425428" style="zoom:80%;" />

```c
sz 文件名 发送：可将云服务器上的文件发送到本地机器的指定位置
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220220205538813.png" alt="image-20220220205538813" style="zoom:80%;" />

### 1.2.3 卸载软件

:yellow_heart: 卸载软件

```c
sudo yum remove sl   以sl小火车为例
```

可能有询问信息，您别问了，直接干掉!

```c
sudo yum -y remove sl
```



# 2. vim

- IDE 集成开发环境：集成了编写编译调试链接运行于一体的开发环境

那么在Linux下如何开发呢？是用vim, gcc, g++, gdb, make, makefile一个个独立的工具。

下面依次介绍。

## 2.1 vim的基本概念

vim就是一个**文本编辑器**，从定位上和记事本没有差别。

vim是一款多模式的编辑器，这里介绍**三种常见模式**：**命令**模式、**插入**模式，**底行**模式。

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220220212614109.png" alt="image-20220220212614109" style="zoom:80%;" />

- [ ] 模式与模式之间的切换都需要经过命令模式，底行模式和插入模式没法相互转换，所以命令模式就是**核心/中间模式**，无脑[***esc***]即可。


:yellow_heart: 1. **命令模式**

默认打开的是命令模式，控制屏幕光标的移动，字符、字或行的删除，移动复制某区段**及**键入***i***进入插入模式；键入[ ***shift + :*** ]进入底行模式。

:yellow_heart: 2. **插入模式** 

即编辑模式。键入***i***进入插入模式，常用的还有a(会向后挪一个字符)或o(会新起一行)

:yellow_heart: 3. **底行模式** 

文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作。 在命令模式下，*shift+:* 即可进入该模式。



## 2.2 vim命令模式指令集

### 2.2.1 移动光标

1. vim可以直接用键盘上的上下左右来移动，但是不建议用，因为某些组合命令必须用HJKL

   ```c
   [h] ←左移一格 
   [j]  ↓下移一格jump
   [k]  ↑上移一格king
   [L] →右移一格
   ```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220220214835009.png" alt="image-20220220214835009" style="zoom:67%;" />

2. **光标位置锚点**

   ```c
   [shift + $]    定位到行首
   [shift + ^]    定位到行尾
   [gg]   		   快速定位到起始行
   [shift + g]    快速定位到结束行     
   ```

   快速定位到某一行

   ```c
   [n + shift + g]	快速定位到某一行
   ```
   
   行内进行跳转 —— 以单词为单位进行前后光标移动
   
   ```c
   [w]	  光标跳到下一个字的开头
   [b]   光标跳到上一个字的开头
   ```
   
   

### 2.2.2 文本操作

:yellow_heart: **复制粘贴**

```c
yy	复制当前行
nyy 多行复制：复制当前及其后共n行
p	粘贴
np 	一次性粘贴n次
```



:yellow_heart: **删除剪切**

```c
x	从左向右删：删除光标所在位置处的一个字符
nx	支持nx
[shift + x]	从右向左删：删除光标前一个位置处的一个字符[X]
nX 			支持nX
```



```c
dd		删除光标所在行
ndd 	删除多行
dd → p 	相当于剪切
```



:yellow_heart: **局部修改**

```c
r + 字符 	替换光标所在处的一个字符
nr + 字符	支持nr
```



插入模式，按`esc`退出

```c
[shift + r]	相当于vs下的insert
```



```c
[shift + ~]	快速大小写转换
```



:yellow_heart: **撤销恢复**

```c
u			撤销误操作
[ctrl + r]	恢复：撤销最近的撤销
```



:yellow_heart: **双屏操作**

底行模式下输入

```c
vs 文件名	分屏
```

![image-20220221163601991](C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220221163601991.png)



```c
[ctrl + ww]	快速切换光标
```

退出双屏：注意现在光标在哪个屏幕代表选中哪个文件`:wq`



上述所有命令理论上确实可以在vim的插入模式用光标操作来代替，但是又慢又low就是了

## 2.3 vim底行模式指令集

先按[esc]确认你已在命令模式，再[shift + :]进入末行模式

```c
set nu		调出行号
set nonu	取消行号
```

退出 ——

```c
q	退出
wq	保存并退出
!	强制[q!][w!][wq!]
```



## 2.4 简单的vim配置

注意：不管是root还是普通用户，配置只会影响自己。

- [ ] vim配置在自己的配置文件中，只会影响自己的操作


- [ ] root有自己的vim配置文件，只会影响自己。


云服务器上，不含这个配置文件，如果没有就自己创建一个，所有的配置都**写入**在这个普通文件中

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220221154028125.png" alt="image-20220221154028125" style="zoom:80%;" />

vim的配置成本还是蛮高的，这里提供汤神的一键式vim环境安装包（gitee上搜索`VimForCpp`即可）

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220221164205901.png" alt="image-20220221164205901" style="zoom:80%;" />



> 关于添加sudo信任关系

以root身份进入家目录`~`

```c
vim /etc/sudoers
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220221162030711.png" alt="image-20220221162030711" style="zoom:80%;" />

`wq!`强制写入并退出即可。

# 3. gcc/g++

gcc是C语言的编译器，g++是Cpp的编译器。

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220224182606003.png" alt="image-20220224182606003" style="zoom:80%;" />

源代码生成**可执行文件**经历了编译+链接，其中编译又分为三个阶段。

1. **预编译**（宏替换、文件包含、条件编译、去注释）
2. **编译**    （生成汇编）
3. **汇编**    （汇编语言生成可重定位目标文件）
4. **链接**    （多个目标文件和链接库经过链接器处理生成可执行程序）

下面在体会每个阶段都做了什么的同时，熟悉gcc指令的选项。

## 3.1 翻译过程&选项

读完本小节，你可以这样快速记住选项

- [ ] 翻译到哪个阶段停止 - `ESc`，看呀，就是你键盘左上角的那个键，但要注意大小写。

- [ ] 对应阶段生成文件的后缀名 - `iso`，是镜像文件后缀名之一。

### 3.1.1 预编译

:yellow_heart: 开始进行翻译，完成预处理后，停下来

```c
gcc -E mytest.c -o hello.i
```

`-o`：output自己指定形成的文件。如果不指定，会把结果全部打印到屏幕上。

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220224192043493.png" alt="image-20220224192043493" style="zoom:80%;" />

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220224191611859.png" alt="image-20220224191611859" style="zoom:80%;" />



### 3.1.2 编译

:yellow_heart: 开始进行翻译，完成编译后，停下来

```c
gcc -S hello.i -o hello.s
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220224192445565.png" alt="image-20220224192445565" style="zoom:80%;" />

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220224192811026.png" alt="image-20220224192811026" style="zoom:80%;" />

计算机不可以直接执行汇编语言。汇编语言也需要编译器。



### 3.1.3 汇编

:yellow_heart: 开始进行翻译，完成汇编后，停下来

```c
gcc -c hello.s -o hello.o
```

汇编形成的二进制文件，并不可以直接执行，是可重定位的目标文件。还需要链接进行合并段表&符号表的合并和重定位。

![image-20220224193421585](C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220224193421585.png)



### 3.1.4 链接

:yellow_heart: 目标文件和链接库经过链接生成**可执行程序**

```c
gcc hello.o -o hello 
```

![image-20220224194113801](C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220224194113801.png)

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220224200313674.png" alt="image-20220224200313674" style="zoom:80%;" />

## 3.2 动态库vs静态库

链接会把自己写的C程序和语言或者第三方库提供的方法关联起来。

函数库分为**静态库**`.o`(windows下为`.lib`)和**动态库**`.so`(windows下为`.dll`)两种，它们都和程序的正确运行紧密相关。

- [ ] **静态链接**时，需要`.a`静态库。静态链接是把库文件的有关代码**拷贝到**我的**可执行文件**中，因此生成的文件比较大，但在运行时也就不再需要任何库文件了，**可移植性**较好。

- [ ] **动态链接**时，需要`.so`动态库。静态链接，并不会把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以**节省**内存和硬盘的**空间**。

我们可以通过`file`命令来查看：gcc**默认**采用**动态链接**的方式，形成可执行文件。

![image-20220224201319402](C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220224201319402.png)

可以通过`ldd`命令来查看可执行程序依赖的库

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220224205054982.png" alt="image-20220224205054982" style="zoom:80%;" />

它们没有绝对的好坏，只有谁更合适。 

注：**g++**和gcc的选项、动静态库链接没有任何差别。

---

若要采用静态链接，需要带选项

```c
gcc hello.c -o hello_static -static
```

注：可能需要下载静态库`libc.a`

安装C静态库 & C++静态库指令如下：

```cpp
sudo yum install glibc-static
sudo yum install libstdc++-static
```

可以看到 ——

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220225090348938.png" alt="image-20220225090348938" style="zoom:80%;" />

# 5. gdb

gdb**调试器**学习成本较高，而且也很不优雅，能做基本调试即可。

## 5.1 release & debug模式

程序发布方式有debug**和**release模式。

Linux下**默认**生成的可执行程序是以*release*版本的，无法调试。如果一个文件可以被调试，它的二进制文件一定加入了一些**调试信息**。

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220224211935512.png" alt="image-20220224211935512" style="zoom:80%;" />

想要调试，用gcc/g++**编译时**需要带上`-g`选项。

```c
gcc hello.c -o hello -g
```

由于加入了调试信息，debug版本的可执行程序更大一些

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220224214113783.png" alt="image-20220224214113783" style="zoom:80%;" />

## 5.2 gdb指令集

为了演示调试指令，先写一段调试代码 ——

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220225162213037.png" alt="image-20220225162213037" style="zoom:80%;" />



:heart: **显示代码**：要打断点，要先知道行号

```c
l/list 	显示源代码
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220225092107566.png" alt="image-20220225092107566" style="zoom:80%;" />



:heart: **断点** `breakpoints`

```c
b 行号	  在某一行设置断点
delete n   删除序号为n的断点（注：删除时不以行号标定）
info b 	   显示断点信息
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220225152813251.png" alt="image-20220225152813251" style="zoom:80%;" />

```c
disable n 	禁用断点
enable n  	启用断点
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220225153205041.png" alt="image-20220225153205041" style="zoom:80%;" />

相当于vs下 ——

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220225093906448.png" alt="image-20220225093906448" style="zoom:80%;" />



```c
r/run	运行程序 - 相当于F5
———————————记得打断点——————————
n/next	逐过程 - 相当于F10
s/step	逐语句 - 相当于F11
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220225154602199.png" alt="image-20220225154602199" style="zoom:80%;" />

注：要调试，首先要让程序跑起来 



:heart: **快速确定代码中是哪一行出错了**

```c
finish 		结束当前函数
c/continue 	直接到下一个断点
until 行号   跳转到指定行    
```

![image-20220225161916142](C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220225161916142.png)



:heart: **监视**

```c
display 变量名	 	常显示
p/P 变量名 	 	打印一次
undisplay 数字 	取消对先前设置的那些变量的跟踪	   	
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220225161236433.png" alt="image-20220225161236433" style="zoom:80%;" />

```c
quit 	退出
```



# 6. make & makefile

一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，*makefile*定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂。*makefile*带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。

- [ ] make 是一条指令，makefile是一个文件
- [ ] makefile中包含着**依赖关系**&**依赖方法**，两者搭配，可以达到形成可执行程序的目的。

:heart: *touch*一个普通文件`Makefile`来表明**依赖关系**和**依赖方法**

```c
touch Makefile 	
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220227161337538.png" alt="image-20220227161337538" style="zoom:80%;" />

`.PHONY:`修饰对应符号，让符号变成**伪目标**（伪目标：总是可以执行的）也确实观察到如果没有对文件进行修改，执行*make*命令是没有效果的(底层是通过对比修改时间和可执行时间实现的)，然而*make clean* 即便刚刚执行过，也可以随便执行。

也可这样写 ——

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220227162958888.png" alt="image-20220227162958888" style="zoom:80%;" />

- [ ] `$@`：目标文件
- [ ] `$^`：文件列表

:heart: **生成项目**&**清理项目**

```c
make 		生成解决方案
make clean 	清理解决方案
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220227161732962.png" alt="image-20220227161732962" style="zoom:80%;" />

相当于vs下 ——

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220227160450295.png" alt="image-20220227160450295" style="zoom:80%;" />

:heart: make会根据你编写的依赖关系，自动推导程序的执行

make会在当前目录下找名字叫*Makefile*或*makefile*的文件。然后它会默认找文件中的**第一个**目标文件（target），并把这个文件作为最终的目标文件。在如下代码中，`mytest`所依赖的`mytest.o`不存在或是被修改，就会执行对应的依赖方法，依赖方法中`myteat.o`又不存在，那么make会在Makefile文件中寻找目标为`test.o`文件的依赖关系，如果找到则再根据其依赖方法生成`test.o`文件，以此类推。（类似于堆栈的过程）。总之，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。



<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220227165442460.png" alt="image-20220227165442460" style="zoom:80%;" />

在进程间通信，再详谈多目标文件生成可执行程序。

# 7. 进度条程序

首先明确两个概念

- [ ] **回车`\r`：**回到当前行的最开始
- [ ] **换行`\n`：**列不变，新起一行

## 7.1 行缓冲区

对比下面两段代码执行结果

```c
// 1.
#include <stdio.h>

int main()
{
     printf("hello Makefile!\n");
     sleep(3);
     return 0;
}

// 2. 发现sleep的过程中，并没有打印。
#include <stdio.h>
#include <unistd.h>

int main()
{
     printf("hello Makefile!");
     sleep(3);
     return 0;
}
```

这意味着*sleep*先于*printf*执行吗？绝对不是！

只是*printf*不带`\n`在向显示器打印时，数据**不会立即刷新**，而是会**暂时保存**在**用户C语言级别**的**缓冲区**中(文件系统详谈)，显示器的刷新策略就是**行刷新**，即`\n`即进行刷新。

:heart: 如果我们又不想换行，又想刷新，可以调用库函数，刷新显示器

```c
fflush(stdout);
```



## 7.2 进度条代码

【百度笔试题】进度条

思路：不换行，从左至右变长

```c
#include<stdio.h>    
#include<string.h>    
#include<unistd.h> //usleep   
    
int main()    
{    
#define NUM 100    
  char bar[NUM+1];    
  memset(bar ,0 ,sizeof(bar));    
  int i = 0;    
  const char* label = "|/-\\";    
  while(i<=100)    
  {    
    printf("[%-100s][%3d%%][%c]\r",bar,i,label[i%4]);
    fflush(stdout);    
    usleep(50000);    
    bar[i] = '=';    
    i++;    
  }    
  printf("\n");                                                                                                                                          
  return 0;    
} 
```

:heart: 小细节还真是蛮多的

- [ ] 进度条[0 ~ 100]：不换行且能刷新，需要`\r`配合*fflush*库函数。

- [ ] 记得休眠`usleep`，单位是微秒$1us = 1/1000ms$，只能在Linux下使用。

  <img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220227201848351.png" alt="image-20220227201848351" style="zoom:80%;" />

- [ ] 这个数组长度给`NUM+1`，并把整个数组`memset`成`\0`，这样不需要在字符串末尾手动添加`\0`。关于`memset`函数 ——

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220227191446757.png" alt="image-20220227191446757" style="zoom:80%;" />

- [ ] `[%-100s]`打印进度条，这样就预留了100个字符的空间，并且是从左向右输出
- [ ] `label`旋转光标，表示当前进度条处于工作状态，注意`\`为特殊字符需要转义

- [ ] 同样为进度条程序编写了`Makefile`文件，这样直接*make*就行了

  <img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220227193843623.png" alt="image-20220227193843623" style="zoom:80%;" />



# 8. git

## 8.0 创建仓库与git clone

:heart: 创建新仓库，老生常谈了

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220227202856649.png" alt="image-20220227202856649" style="zoom:80%;" />

:heart: 创建本地代码仓

```c
git clone [url]  这里的 url 就是刚刚建立好的仓库的链接.
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220227203225577.png" alt="image-20220227203225577" style="zoom:80%;" />

下面仅介绍git命令的简单操作，git三板斧。

## 8.1 git add

:yellow_heart: 添加

```c
git add 文件名
```

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220227210723885.png" alt="image-20220227210723885" style="zoom:80%;" />

## 8.2 git commit

:yellow_heart: 提交改动到本地

```c
git commit -m "日志信息"
```

日志信息必须写，否则无法提交，且不能胡写。

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220227210028722.png" alt="image-20220227210028722" style="zoom:80%;" />



## 8.3 git push

:yellow_heart: 同步到远端服务器上

```c
git push
```

需要认证，用户名密码

<img src="C:\Users\13136\AppData\Roaming\Typora\typora-user-images\image-20220227211147068.png" alt="image-20220227211147068" style="zoom:67%;" />

持续更新~@边通书

